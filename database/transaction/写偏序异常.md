## 写偏序异常

在快照隔离并发控制技术中并发的事务因不满足约束而发生的异常，称为“写偏序(Write Skew)”

### 两个事务引发异常

| 时间 | T1                                                           | T2                                                           |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| t0   | x=(select count(*) from doctors where on-call=true)          |                                                              |
| t1   |                                                              | x=(select count(*) from doctors where on-call=true)          |
| t2   | if x >=2 then<br>UPDATE doctors SET on-call=false WHERE name=Alice |                                                              |
| t3   |                                                              | if x >=2 then<br/>UPDATE doctors SET on-call=false WHERE name=Bob |
| t4   | Commit                                                       |                                                              |
| t5   |                                                              | Commit                                                       |

说明：

根据时间顺序，T1事务在t0时刻读取了在打电话的值班医生个数，T2事务在t1时刻也读取了在打电话的值班医生个数。事务T1在t2时刻进行判断，如果在打电话的值班医生个数大于等于2人则请Alice医生停止打电话。事务T2在t3时刻进行判断，如果在打电话的值班医生个数大于等于2人则请Bob医生停止打电话。然后T1事务，T2事务分别提交。在这种并发的情况下，允许事务T1和事务T2都提交成功。如果串行执行事务，先执行事务T1后执行事务T2，Alice会停止打电话但Bob不会停止，这与前一种情况的结果不同；如果先执行事务T2后执行事务T1，Bob会停止打电话但Alice不会停止，这与前一种情况的结果也不同；这表明前一种并发执行是非序列化的，而此时，事务T1、T2并发时违反了约束（约束为：如果同时打电话的人数大于2人则请Alice或Bob医生其中一人停止打电话直到同时打电话的人数少于2人），发生了写偏序。

关键点是：事务均可提交成功但结果会违反约束。

### 三个事务引发异常

| 时间 | T1                                               | T2                                      | T3                      |
| ---- | ------------------------------------------------ | --------------------------------------- | ----------------------- |
| t0   |                                                  | x=(select current_batch)                |                         |
| t1   |                                                  |                                         | INCREMENT current_batch |
| t2   |                                                  |                                         | commit                  |
| t3   | x=(select current_batch)                         |                                         |                         |
| t4   | select sum(amount) from receipts where batch=x-1 |                                         |                         |
| t5   | Commit                                           |                                         |                         |
| t6   |                                                  | INSERT INTO receipts values(x,somedata) |                         |
| t7   |                                                  | Commit                                  |                         |

说明：

对于这种情况，后两个并发更新事务T3和T2是可串行化且不存在任何异常，但是一个只读事务T1出现在某个时刻却可能正好造成问题。所出现的问题是这样的，当事务T3提交时，T2处于活跃状态，这时T1启动要读取事务T2和T3涉及的数据(current_batch和receipts),这时，事务T1的快照包含了事务T3插入后的结果（因为T3已经提交），但是，事务T2没有提交，它的插入操作数据不包含在T1的快照中。在优先图中会造成一个环，说明这样的调度是非可串行化的。

为解决调度是非可串行化的这一问题，数据库引擎必须在事务提交时(甚至是环一形成即立刻回滚其中的一个事务)而不是在快照上检查完整性约束。

